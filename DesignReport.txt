Phase 1: Registration 
Relay will get the Client’s identity and public key.  
a) Client → Relay 
{ ClientID, ClientPubKey, Timestamp, Signature_Client } 
The Relay will get the Client ID, Client Public Key, Timestamp, and Client Signature. 
Signature_Client = Sign{ClientPriv}(ClientID || ClientPubKey || Timestamp) 
b) Relay 
The relay verifies the signature against known Client public key 
The relay stores the digital signature that the client generates. 
Security Feature: - 
Ensure relay has the correct public key for each client - 
Digital signature prevent impersonation during registration 
Phase 2: Authentication 
Clients will verify that they are communicating with the real relay. The relay confirms if the 
Client is legitimate. 
a) The Client will encrypt a nonce with Relay’s Public key and sends it 
M1 = EPR (NC) 
b) Relay decrypts, signs the nonce and returns it 
NC = DSK(M1) 
M2 = SignSK(NC) 
c) Client verifies the signed nonce using Relay’s public key 
VerifyPR  (NC, M2) = True  
Client and Relay are Authenticated before the session setup. 
Authentication is done using asymmetric encryption. 
Phase 3: Session Setup & Key Agreement 
Create a new session between the two clients through the Relay.  
a) Ca → Relay 
{SessionRequest, ReceiverID, NonceA, EphemeralDHa, SignatureCa} 
EphemeralDHa = gᵃ mod p (public DH value) 
Signature authenticates message  
b) Relay → Cb : Forwards request  
c) Cb → Relay 
{SessionResponse, SenderID, NonceA, NonceB, EphemeralDHb, SignatureCb} 
EphmeralDHb = gᵇ mod p (public DH value) 
Signed response binds Cb’s DH to its identity 
d) Relay → Ca : Forwards response 
e) Key Derivation 
Shared Secret: K = (EphemeralDHb)a mod p = (EphemeralDHa)b mod p 
Salt: 
Salt = Hash(SessionID || NonceA || NonceB) 
Session Keys:  
Kenc = HKDF(Salt, K,  "encryption") 
Kmac = HKDF(Salt, K,  "authentication") 
Security Feature: - 
The Relay cannot compute the shared secret which means no access to a or b - 
Signatures prevent man in the middle attacks since relay cannot swap DH values 
Phase 4: Secure Message Exchange 
Since the session keys are derived, clients can now send each other messages securely.  
Message Format: 
{SessionID, SeqNo, Ciphertext, HMAC} 
Ciphertext: XOR(Plaintext, KDF(Kenc, SeqNo))  
HMAC: HMAC(Kmac, SessionID || SeqNo || Ciphertext)  
Receiver Processing: 
a) verify HMAC (integrity + authenticity) 
b) Check SeqNo > last seen (no replay attack) 
c) Decrypt using Kenc 
Key Refresh: Periodically, Clients will re-run ephemeral DH to generate new keys to maintain 
forward secrecy. 